import groovy.json.JsonSlurper
import thermos.CreateChangelog
import thermos.InstallBundle
import thermos.VersionParser
import thermos.VersionSetter

tasks.whenTaskAdded {
    if (it.name.startsWith('publish')) it.dependsOn 'preparePublication'
}

buildscript {
    repositories {
		jcenter()
        maven {
            name 'mcimaginarium'
            url 'https://repo.mcimaginarium.co.uk/maven/'
        }
        maven {
            name 'forge'
            url 'https://files.minecraftforge.net/maven/'
        }
        maven {
            name 'sonatype'
            url 'https://oss.sonatype.org/content/repositories/snapshots/'
        }
        maven {
            name 'spigot'
            url 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'
        }
        mavenCentral()
        mavenLocal()
    }
    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:1.2.0.777'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.8'
}

apply plugin: 'maven'
apply plugin: 'cauldron'
apply plugin: 'maven-publish'
apply plugin: 'signing'

repositories {
    clear()
	jcenter()
    maven {
        name 'mcimaginarium'
        url 'https://repo.mcimaginarium.co.uk/maven/'
    }
    maven {
        name 'sonatype'
        url 'https://oss.sonatype.org/content/repositories/snapshots/'
    }
    maven {
        name 'forge'
        url 'https://files.minecraftforge.net/maven/'
    }
    maven {
        name 'minecraft'
        url 'https://libraries.minecraft.net/'
    }
    maven {
        name 'spigot'
        url 'https://hub.spigotmc.org/nexus/content/repositories/snapshots/'
    }
    mavenCentral()
    mavenLocal()
}

minecraft {
    version = '1.7.10'
    mcpVersion = '9.08'
    mainClass = 'cpw.mods.fml.relauncher.ServerLaunchWrapper'
    tweakClass = 'cpw.mods.fml.common.launcher.FMLTweaker'
    installerVersion = "1.4"
    srgExtra "PK: org/bukkit/craftbukkit org/bukkit/craftbukkit/v1_7_R4"
}

group = 'pw.prok'

ext.buildInfoCached = null;

public boolean isOfficial() {
	if (project.hasProperty('officialBuild')) {
		return true;
	}
	else {
		return false;
	}
}

def buildInfo(String key) {
    if (!buildInfoCached) {
        if (isOfficial()) {
            buildInfoCached = new JsonSlurper().parse(new URL("https://api.mcimaginarium.co.uk/thermos/version/"))
        } else {
			buildInfoCached = [
					nextRevisionNumber         : 'X'
			]
        }
    }
    return key ? buildInfoCached[key] : buildInfoCached;
}

ext.gitInfoCached = null;

def gitInfo(String key) {
    if (!gitInfoCached) {
        if (file('.git').exists()) {
            gitInfoCached = [
                    hash    : ['git', 'log', "--format=%h", '-n', '1'].execute().text.trim(),
                    fullHash: ['git', 'log', "--format=%H", '-n', '1'].execute().text.trim(),
                    branch  : System.getenv("BRANCH") ?: ['git', 'symbolic-ref', '--short', 'HEAD'].execute().text.trim(),
                    message : ['git', 'log', "--format=%B", '-n', '1'].execute().text.trim()
            ]
        } else {
            gitInfoCached = [
                    hash    : 'NOT_A_GIT',
                    fullHash: 'NOT_A_GIT',
                    branch  : 'NOT_A_GIT',
                    message : 'NOT_A_GIT'
            ]
        }
    }
    return key ? gitInfoCached[key] : gitInfoCached;
}

public boolean isTravis() {
  String user = System.getProperty("user.name");
  return user.equals("travis");
}

def getGitBranch() {
    def branch = gitInfo("branch")
    if (branch.equals("master")) {
		branch = "Stable"
	}
    else if (branch.contains("-dev") || branch.contains("-Dev")) {
		branch = "Dev"
	}
	else {
		branch = "Bleeding"
	}
	return branch;
}
ext.branch = getGitBranch()
ext.gitHash = gitInfo("hash")
ext.mcVersion = minecraft.version
ext.forgeVersion = VersionParser.parseForgeVersion(file('forge/src/main/java/net/minecraftforge/common/ForgeVersion.java'), file('src/main/resources/fmlversion.properties'))
ext.nextRevisionNumber = buildInfo('nextRevisionNumber')

if (isOfficial() && isTravis()) {
	ext.nextBuildNumber = System.getenv('TRAVIS_BUILD_NUMBER')
}
else if (isOfficial() == false && isTravis()) {
	ext.nextBuildNumber = 'System.getenv('TRAVIS_BUILD_NUMBER')-SNAPSHOT'
}
else {
	ext.nextBuildNumber = 'SNAPSHOT'
}

version = "${mcVersion}-${forgeVersion}-${nextRevisionNumber}-${nextBuildNumber}"

launch4j {
    jreMinVersion = '1.6.0'
}

configurations {
    compile.extendsFrom exported
    libraries
    bootstrap
	compile
}

dependencies {
    bootstrap 'pw.prok:KBootstrap:0.3.3'
    libraries 'net.minecraft:launchwrapper:1.12@jar'
    libraries 'org.ow2.asm:asm-all:5.0.3'
    libraries 'com.typesafe.akka:akka-actor_2.11:2.3.3'
    libraries 'com.typesafe:config:1.2.1'
    libraries 'org.scala-lang:scala-actors-migration_2.11:1.1.0'
    libraries 'org.scala-lang:scala-compiler:2.11.7'
    libraries 'org.scala-lang.plugins:scala-continuations-library_2.11:1.0.2'
    libraries 'org.scala-lang.plugins:scala-continuations-plugin_2.11.2:1.0.2'
    libraries 'org.scala-lang:scala-library:2.11.7'
    libraries 'org.scala-lang:scala-parser-combinators:2.11.0-M4'
    libraries 'org.scala-lang:scala-reflect:2.11.7'
    libraries 'org.scala-lang:scala-swing:2.11.0-M7'
    libraries 'org.scala-lang:scala-xml:2.11.0-M4'
    libraries 'net.sf.jopt-simple:jopt-simple:4.7'
    libraries 'lzma:lzma:0.0.1'
    libraries 'org.yaml:snakeyaml:1.15'
    libraries 'commons-lang:commons-lang:2.6'
    libraries 'org.avaje:ebean:2.8.1'
    libraries 'jline:jline:2.12.1'
    libraries 'net.md-5:SpecialSource:1.7.4'
    libraries 'net.sourceforge.argo:argo:2.25'
	libraries 'org.fusesource.jansi:jansi:1.8'	
    libraries 'com.googlecode.json-simple:json-simple:1.1'
    libraries 'org.xerial:sqlite-jdbc:3.7.2'
    libraries 'mysql:mysql-connector-java:5.1.42'
    libraries 'javax.persistence:persistence-api:1.0.2'
    libraries 'net.minecraft:server:1.7.10'
    libraries 'pw.prok:KImagine:0.2.0@jar'
    libraries 'org.apache.httpcomponents:httpclient:4.4.1'
	libraries 'colt:colt:1.2.0'
	libraries 'java3d:vecmath:1.3.1'
	libraries 'org.jetbrains.kotlin:kotlin-runtime:1.1.4-2'
	libraries 'co.aikar:minecraft-timings:1.0.4'
    libraries 'net.openhft:affinity:3.0.1'
	libraries 'com.koloboke:koloboke-impl-jdk8:1.0.0'
	compile 'org.projectlombok:lombok:1.16.18'
}

packageUniversal {
    from { configurations.exported.collect { it.isDirectory() ? it : zipTree(it) } }
}

def String repeat(String string, int times) {
    StringBuilder builder = new StringBuilder(string.length() * times)
    times.times { builder.append(string) }
    builder as String
}

def generateClasspath(boolean legacy = false) {
    def classpath = ''
    configurations.libraries.resolvedConfiguration.resolvedArtifacts.collect { it.moduleVersion.id }.each {
        def jar = "${it.group.replace('.', '/')}/${it.name}/${it.version}/${it.name}-${it.version}.jar"
        classpath += " ${legacy ? 'libraries/' : repeat('../', (group as String).split('\\.').length + 2)}${jar}"
    }
    return classpath.trim()
}

def generateManifest(boolean legacy = false) {
    [
            'Thermos-Git-Branch'    : gitInfo('branch'),
            'Thermos-Git-Hash'      : gitInfo('fullHash'),
            'Thermos-Group'         : project.group,
            'Thermos-Channel'       : project.name,
            'Thermos-Version'       : project.version,
			'Thermos-Build'         : project.nextBuildNumber,
			'Thermos-Revision'      : project.nextRevisionNumber,
            'Thermos-Legacy'        : legacy,
			'Thermos-Official'      : isOfficial(),
            'Implementation-Vendor' : 'MCImaginarium',
            'Implementation-Title'  : project.name,
            'Implementation-Version': '1.7.10-R0.1-SNAPSHOT',
            'Specification-Vendor'  : 'Bukkit Team',
            'Specification-Title'   : 'Bukkit',
            'Specification-Version' : '1.7.10-R0.1-SNAPSHOT',
            'Forge-Version'         : VersionParser.parseForgeVersion(file('forge/src/main/java/net/minecraftforge/common/ForgeVersion.java'), file('src/main/resources/fmlversion.properties')),
            'TweakClass'            : 'cpw.mods.fml.common.launcher.FMLTweaker',
            'Main-Class'            : 'cpw.mods.fml.relauncher.ServerLaunchWrapper',
            'Class-Path'            : generateClasspath(legacy)
    ]
}

task setForgeBuildNumber(type: VersionSetter) {
	forgeBuild forgeBuildNumber
	forgeVersionFile = file('forge/src/main/java/net/minecraftforge/common/ForgeVersion.java')
	forgeModLoaderVersionFile = file('src/main/resources/fmlversion.properties')
}

tasks.packageUniversal {
    classifier = 'server'
    setManifest {}
    manifest.attributes(generateManifest(true))
}

task jar(type: Jar, dependsOn: packageUniversal) {
    destinationDir file("${buildDir}/distributions")
    from zipTree(tasks.packageUniversal.archivePath)
    manifest.attributes(generateManifest())
}

tasks.createChangelog.onlyIf { false }
tasks.packageInstaller.onlyIf { false }

task packageChangelog(type: CreateChangelog) {
    onlyIf { project.hasProperty('officialBuild') }
    classifier = 'changelog'
    extension = 'txt'
    oldChangelogUrl = "https://api.mcimaginarium.co.uk/thermos/changelog.txt"
    hash = gitInfo('hash')
    message = gitInfo('message')
    version = project.version
	build = project.nextBuildNumber
}

task api(type: Zip, dependsOn: packageUniversal) {
    setExtension('jar')
    classifier = 'api'
    from (zipTree(tasks.packageUniversal.archivePath)) {
        include ("org/bukkit/**")
        include ("org/spigotmc/event/**")
        include ("org/spigotmc/CustomTimingsHandler*")
        exclude ("org/bukkit/craftbukkit/**")
    }
}

task bundleStub(type: Jar) {
    classifier = 'stub'
    manifest.attributes([
            'Main-Class': 'cpw.mods.fml.relauncher.ServerLaunchWrapper',
            'Class-Path': "libraries/${project.group.replace('.', '/')}/${project.name}/${project.version}/${project.name}-${project.version}.jar"
    ])
}

task installBundle(type: InstallBundle, dependsOn: jar) {
    serverJar tasks.jar.archivePath
    bootstrapClasspath configurations.bootstrap
    bootstrapMain 'pw.prok.bootstrap.Main'
	repos=repositories
}

task packageBundle(type: Zip, dependsOn: installBundle) {
    classifier = 'bundle'
    from fileTree(installBundle.installLocation)
    from bundleStub
    rename bundleStub.archiveName, 'Thermos.jar'
}

task signJars(type: Sign, dependsOn: [packageUniversal, packageChangelog, jar, installBundle, 'generatePomFileForMavenPublication']) {
    sign packageUniversal
    sign packageChangelog
    sign jar
}

tasks.withType(Zip) { task ->
    task.doLast {
        ant.checksum(file: it.archivePath, algorithm: "md5")
		ant.checksum(file: it.archivePath, algorithm: "sha1")
    }
}

task signPom(type: Sign, dependsOn: 'generatePomFileForMavenPublication') {
    outputs.upToDateWhen { false }
    sign file("${buildDir}/publications/maven/pom-default.xml")
}

task preparePublication(dependsOn: [signJars, signPom]) {}

def getPomSignature = { return project.tasks.signPom.signatureFiles.collect { it }[0] }

def getSignatureFiles = {
    def allFiles = project.tasks.signJars.signatureFiles.collect { it }
    def signedServer = allFiles.find { it.name.contains('-server') }
    def signedChangelog = allFiles.find { it.name.contains('-changelog') }
    def signedJar = (allFiles - [signedServer, signedChangelog])[0]
    return [
            [archive: signedServer, classifier: 'server', extension: 'jar.asc'],
            [archive: signedChangelog, classifier: 'changelog', extension: 'txt.asc'],
            [archive: signedJar, classifier: null, extension: 'jar.asc']
    ]
}
 
publishing {
    repositories {
	    /*
        maven {
            name 'mcimaginarium'
            url 'sftp://repo.mcimaginarium.co.uk:21/maven/'
            credentials 
			{
                username project.hasProperty('mcimaginariumUsername') ? mcimaginariumUsername : null
                password project.hasProperty('mcimaginariumPassword') ? mcimaginariumPassword : null
            }
        }
	    */
        maven {
            url = mavenLocal()
        }
    }
 
    publications {
        maven(MavenPublication) {
            getSignatureFiles().each { signature ->
                artifact(signature.archive)	{
                    classifier = signature.classifier
                    extension = signature.extension
                }
            }
            artifact(getPomSignature()) {
                classifier = null
                extension = 'pom.asc'
            }
            artifact packageUniversal
            artifact packageChangelog
            artifact jar
			
            pom.withXml {
                asNode().children().last() + {
                    resolveStrategy = Closure.DELEGATE_FIRST
					name 'Thermos'
                    description 'Free (as in "Free speech") Forge and Bukkit compatible Minecraft server'
                    url 'https://github.com/MCImaginarium/Thermos'
                    licenses {
                        license {
                            name 'MIT License'
                            url 'https://raw.githubusercontent.com/MCImaginarium/Thermos/master/LICENSE'
                            distribution 'repo'
                        }
                    }
                    developers {
                        developer {
                            id 'Prototik'
                            name 'Sergey Shatunov'
                            email 'me@prok.pw'
                        }
                        developer {
                            id 'Terminal Access'
                            name 'Lee Wickham'
                            email 'lee.wickham@lee-wickham.co.uk'
                        }
                    }
                    scm {
                        url 'https://github.com/MCImaginarium/Thermos'
                        connection 'https://github.com/MCImaginarium/Thermos.git'
                        developerConnection 'https://github.com/MCImaginarium/Thermos.git'
                    }
					repositories {
					    repository {
						    id 'mcimaginarium'
							url 'https://mcimaginarium.co.uk/maven/'
						}
					}
					distributionManagement {
					    repository 
						{
						    id 'mcimaginarium'
							url 'https://mcimaginarium.co.uk/maven/'
						}
					}
                }
            }
        }
    }
}

tasks.generateProjectCauldron << {
    def file = new File('eclipse/cauldron/build.gradle')
    file.append('''
repositories {
    clear()
    maven {
        name 'mcimaginarium'
        url 'https://repo.mcimaginarium.co.uk/maven/'
    }
    maven {
        name 'forge'
        url 'https://files.minecraftforge.net/maven/'
    }
    maven {
        name 'minecraft'
        url 'https://libraries.minecraft.net/'
    }
    mavenCentral()
    mavenLocal()
}

dependencies {
''')
    configurations.libraries.resolvedConfiguration.resolvedArtifacts.collect { it.moduleVersion.id }.each { module ->
        if (['net.minecraft:server:', 'org.ow2.asm:asm-all'].findAll { (module as String).startsWith it }.size() > 0) {
            return
        }
        file.append("    compile '${module}'\n")
    }
    file.append('}')
}

task resolveAllDependencies {
    doLast {
        configurations.each { it.resolve() }
    }
}

subprojects {
    apply plugin: 'java'
    repositories {
        mavenCentral()
    }
}